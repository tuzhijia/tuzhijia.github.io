<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>秃秃の拼图器</title>
  <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=ZCOOL+XiaoWei&family=Noto+Sans+SC&family=Noto+Serif+SC&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: 'ZCOOL KuaiLe', cursive;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    body.light {
      background-color: #FFE4E1;
      color: #000;
    }
    body.dark {
      background-color: #000000;
      color: #fff;
    }
    /* For custom background, let the body background-image handle appearance */
    header {
      text-align: center;
      padding: 1em;
      font-size: 1.5em;
      border: 4px dashed #FDC2CF;
      border-radius: 8px;
    }
    .container {
      padding: 1em;
      display: flex;
      flex-direction: column;
      gap: 1em;
      max-width: 600px;
      margin: auto;
    }
    .row {
      display: flex;
      align-items: center;
      gap: 1em;
      flex-wrap: wrap;
    }
    input[type="number"], input[type="file"], input[type="color"], 
    input[type="text"] {
      flex: 1;
      padding: 0.5em;
    }
    button {
      padding: 0.7em 1.2em;
      background-color: #ffb6c1;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }
    button:hover {
      background-color: #ff8aa1;
    }
    canvas {
      max-width: 100%;
      height: auto;
      border: 2px dashed #aaa;
      display: block;
      margin: auto;
    }
    .theme-switcher {
      display: flex;
      gap: 0.5em;
    }
    .hidden {
      display: none;
    }
    .bg-upload-section {
      border: 1px dashed #ccc;
      padding: 1em;
      margin-top: 1em;
    }
    .menu-btn {
      position: fixed;
      top: 10px;
      left: 10px;
      font-size: 28px;
      background-color: #FDC2CF;
      color: #3D1E16;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 1000;
      border: 2px solid #3D1E16;
    }
    #menuToggle {
      display: none;
    }
    .sidebar {
      position: fixed;
      top: 0;
      left: -200px;
      width: 160px;
      height: 100%;
      background-color: #FFF3C7;
      padding-top: 60px;
      transition: left 0.3s ease;
      border-right: 2px dashed #FDC2CF;
      z-index: 600;
    }
    .sidebar a {
      display: block;
      color: #3D1E16;
      padding: 12px 16px;
      text-decoration: none;
      font-size: 18px;
    }
    .sidebar a:hover {
      background-color: #FDC2CF;
      color: #fff;
      border-radius: 4px;
    }
    #menuToggle:checked ~ .sidebar {
      left: 0;
    }
  </style>
</head>
<body class="light">
  <input type="checkbox" id="menuToggle">
  <label for="menuToggle" class="menu-btn">&#9776;</label>
  <nav class="sidebar">
    <a href="index.html">首页</a>
    <a href="pintu.html">秃秃の拼图器</a>
    <a href="shuiyin.html">秃秃の水印机</a>
  </nav>
  <header>秃秃の拼图器</header>
  <div class="container">
    <div class="row">
      <label>选择拼图图片：</label>
      <input type="file" id="images" multiple accept="image/*">
    </div>
    <div class="row">
      <label>行：</label>
      <input type="number" id="rows" value="3" min="1">
    </div>
    <div class="row">
      <label>列：</label>
      <input type="number" id="cols" value="3" min="1">
    </div>
    <div class="row">
      <label>边框颜色：</label>
      <input type="color" id="colorA" value="#FF0000">
      <input type="text" id="hexA" placeholder="#FF0000">
    </div>
    <div class="row">
      <label>填充颜色：</label>
      <input type="color" id="colorB" value="#FFFFFF">
      <input type="text" id="hexB" placeholder="#FFFFFF">
      <button onclick="setTransparent()" title="只显示边框，没有填充">透明色</button>
      <span style="margin-left:5px;color:#666;">(只显示边框)</span>
    </div>
    <div class="row">
      <label>字体选择：</label>
      <button onclick="selectFont('ZCOOL KuaiLe')">默认字体</button>
      <button onclick="selectFont('Noto Sans SC')">微软雅黑 (类似)</button>
      <button onclick="selectFont('ZCOOL XiaoWei')">方圆体 (类似)</button>
      <button onclick="selectFont('Noto Serif SC')">宋体 (类似)</button>
    </div>
    <div class="row">
      <label>双拼渐变：</label>
      <input type="checkbox" id="gradientCheck" onchange="toggleGradient(this.checked)">
      <input type="range" id="gradientRange" min="0" max="100" value="50" class="hidden">
    </div>
    <div class="row">
      <label>背景颜色：</label>
      <input type="color" id="bgColorPicker" value="#FFB7C5">
      <input type="text" id="bgHexColor" placeholder="#FFB7C5">
    </div>
    <div class="row">
      <label>拼图预览：</label>
    </div>
    <canvas id="preview"></canvas>
    <div class="row">
      <label>标序号模式：</label>
      <select id="numberMode">
        <option value="normal">普通标序号</option>
        <option value="four-grid">四宫格标序号</option>
      </select>
    </div>
    <div class="row">
      <button onclick="generateGrid()">生成拼图</button>
      <button onclick="downloadImage()">下载图片</button>
      <button onclick="toggleNumbers()">标序号</button>
    </div>
    <div class="row theme-switcher">
      <button onclick="setTheme('light')">☀️ 白天</button>
      <button onclick="setTheme('dark')">🌙 深夜</button>
      <button onclick="setTheme('custom')">🖼️ 自定义</button>
    </div>
    <div class="bg-upload-section hidden" id="bgUploader">
      <label>上传自定义背景：</label>
      <input type="file" id="bgInput" accept="image/*">
    </div>
  </div>  
  <script>
    const canvas = document.getElementById('preview');
    const ctx = canvas.getContext('2d');
    const hexA = document.getElementById('hexA');
    const colorA = document.getElementById('colorA');
    const hexB = document.getElementById('hexB');
    const colorB = document.getElementById('colorB');
    const gradientCheck = document.getElementById('gradientCheck');
    const gradientRange = document.getElementById('gradientRange');
    const bgUploader = document.getElementById('bgUploader');
    const bgInput = document.getElementById('bgInput');
    const bgHexColor = document.getElementById('bgHexColor');
    const bgColorPicker = document.getElementById('bgColorPicker');
    const numberMode = document.getElementById('numberMode');
    
    let theme = 'light';
    let bgImage = null;
    let numbersVisible = false;
    let originalImageData = null;
    let numberFont = 'ZCOOL KuaiLe';

    colorA.addEventListener('input', () => {
      hexA.value = colorA.value;
    });
    hexA.addEventListener('input', () => {
      colorA.value = hexA.value;
    });
    colorB.addEventListener('input', () => {
      hexB.value = colorB.value;
      colorB.style.opacity = '1';
    });
    hexB.addEventListener('input', () => {
      colorB.value = hexB.value;
    });

    bgHexColor.value = bgColorPicker.value;
    bgColorPicker.addEventListener('input', () => {
      bgHexColor.value = bgColorPicker.value;
    });
    bgHexColor.addEventListener('input', () => {
      bgColorPicker.value = bgHexColor.value;
    });

    function setTransparent() {
      hexB.value = '';
      colorB.value = '#FFFFFF';
      colorB.style.opacity = '0';
    }
    function toggleGradient(checked) {
      if (checked) {
        gradientRange.classList.remove('hidden');
      } else {
        gradientRange.classList.add('hidden');
      }
    }
    function selectFont(font) {
      numberFont = font;
    }
    
    bgInput.addEventListener('change', () => {
      const file = bgInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          bgImage = img;
        };
        img.src = reader.result;
        if (theme === 'custom') {
          document.body.style.backgroundImage = `url('${reader.result}')`;
          document.body.style.backgroundSize = 'cover';
          document.body.style.backgroundPosition = 'center';
        }
      };
      reader.readAsDataURL(file);
    });
    
    function setTheme(mode) {
      theme = mode;
      document.body.className = mode;
      if (mode === 'custom') {
        bgUploader.classList.remove('hidden');
      } else {
        bgUploader.classList.add('hidden');
        bgImage = null;
        document.body.style.backgroundImage = 'none';
      }
    }
    
    async function generateGrid() {
      numbersVisible = false;
      originalImageData = null;
    
      const files = document.getElementById('images').files;
      const rows = parseInt(document.getElementById('rows').value);
      const cols = parseInt(document.getElementById('cols').value);
      const images = await Promise.all([...files].map(file => loadImage(file)));
      if (images.length > 0) {
        const firstRatio = getAspectRatio(images[0]);
        if (!images.every(img => getAspectRatio(img) === firstRatio)) {
          alert('所有图片必须为相同比例！');
          return;
        }
      }
      const imgWidth = images[0] ? images[0].width : 0;
      const imgHeight = images[0] ? images[0].height : 0;
      canvas.width = cols * imgWidth;
      canvas.height = rows * imgHeight;
      if (theme === 'custom' && bgImage) {
        ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = bgHexColor.value || '#FFB7C5';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const idx = r * cols + c;
          if (images[idx]) {
            ctx.drawImage(images[idx], c * imgWidth, r * imgHeight);
          }
        }
      }
      originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    }
    
    function toggleNumbers() {
      if (!originalImageData) {
        return;
      }
      const rows = parseInt(document.getElementById('rows').value);
      const cols = parseInt(document.getElementById('cols').value);
      const pieceWidth = canvas.width / cols;
      const pieceHeight = canvas.height / rows;
      const imagesCount = document.getElementById('images').files.length;
    
      if (!numbersVisible) {
        ctx.putImageData(originalImageData, 0, 0);
        ctx.textAlign = 'center';
        if (numberMode.value === 'normal') {
          if (!gradientCheck.checked) {
            ctx.textBaseline = 'bottom';
            for (let i = 0; i < imagesCount; i++) {
              const r = Math.floor(i / cols);
              const c = i % cols;
              const x = c * pieceWidth + pieceWidth / 2;
              const y = r * pieceHeight + pieceHeight - (pieceHeight * 0.05);
              const fontSize = pieceHeight / 5;
              ctx.font = `bold ${fontSize}px ${numberFont}`;
              ctx.lineWidth = 0.5;
              ctx.strokeStyle = hexA.value || '#000000';
              ctx.fillStyle = hexB.value || 'transparent';
              if (hexB.value) {
                ctx.fillText((i+1).toString(), x, y);
              }
              ctx.strokeText((i+1).toString(), x, y);
            }
          } else {
            const ratio = gradientRange.value / 100;
            ctx.textBaseline = 'bottom';
            for (let i = 0; i < imagesCount; i++) {
              const r = Math.floor(i / cols);
              const c = i % cols;
              const x = c * pieceWidth + pieceWidth / 2;
              const y = r * pieceHeight + pieceHeight - (pieceHeight * 0.05);
              const fontSize = pieceHeight / 5;
              ctx.font = `bold ${fontSize}px ${numberFont}`;
              const colorAMix = hexA.value || '#000000';
              const colorBMix = hexB.value || '#FFFFFF';
              function hexToRgb(hex) {
                if (hex === '') return [0,0,0];
                const v = hex.replace('#','');
                const bigint = parseInt(v, 16);
                if (v.length === 6) {
                  return [(bigint>>16)&255, (bigint>>8)&255, bigint&255];
                } else if (v.length === 3) {
                  return [parseInt(v[0]+v[0],16), parseInt(v[1]+v[1],16), parseInt(v[2]+v[2],16)];
                }
                return [0,0,0];
              }
              function rgbToHex(r,g,b) {
                r = Math.round(r); g = Math.round(g); b = Math.round(b);
                return "#" + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
              }
              const rgbA = hexToRgb(colorAMix);
              const rgbB = hexToRgb(colorBMix);
              const mixed = rgbA.map((a,i) => a*(1-ratio) + rgbB[i]*ratio);
              const mixedHex = rgbToHex(...mixed);
              ctx.fillStyle = mixedHex;
              ctx.fillText((i+1).toString(), x, y);
            }
          }
        } else {
          ctx.font = `bold ${pieceHeight/10}px ${numberFont}`;
          ctx.textBaseline = 'bottom';
          let number = 1;
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const baseX = c * pieceWidth;
              const baseY = r * pieceHeight;
              const subWidth = pieceWidth / 2;
              const subHeight = pieceHeight / 2;
              const offsetTop = pieceHeight * 0.025;
              const offsetBottom = pieceHeight * 0.05;
              const xTL = baseX + subWidth / 2;
              const yTL = baseY + subHeight - offsetTop;
              ctx.fillStyle = hexB.value || '#ffffff';
              ctx.fillText(number.toString(), xTL, yTL); number++;
              const xTR = baseX + 3 * subWidth / 2;
              const yTR = baseY + subHeight - offsetTop;
              ctx.fillText(number.toString(), xTR, yTR); number++;
              const xBL = baseX + subWidth / 2;
              const yBL = baseY + pieceHeight - offsetBottom;
              ctx.fillText(number.toString(), xBL, yBL); number++;
              const xBR = baseX + 3 * subWidth / 2;
              const yBR = baseY + pieceHeight - offsetBottom;
              ctx.fillText(number.toString(), xBR, yBR); number++;
            }
          }
        }
      } else {
        ctx.putImageData(originalImageData, 0, 0);
      }
      numbersVisible = !numbersVisible;
    }
    
    function loadImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.src = reader.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    function getAspectRatio(img) {
      return (img.width / img.height).toFixed(2);
    }
    
    function downloadImage() {
      const link = document.createElement('a');
      link.download = '拼图.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    }
  </script>
</body>
</html>
